.. -*- coding: utf-8-unix -*- 

====
開発
====

Fabricの開発チームは ``bitprophet`` こと `Jeff Forcier<http://bitprophet.org>`_ を筆頭としています。
数十の開発者がパッチとアイディアを個人のメールや `Redmine <http://code.fabfile.org>`_ の
`mailing list <http://lists.nongnu.org/mailman/listinfo/fab-user>`_ や `GitHub
<http://github.com/bitprophet/fabric>`_ などから提出し、貢献しています

コードの取得
=========

Fabricのソースコードの取得については　:doc:`installation` ページの :ref:`source-code-checkouts`
セクションを見てください。

貢献するには
=========

Fabricに貢献するには:

* **Fabricを使ってフィードバックを送りましょう！** これはプロジェクトの成長にとって最も簡単で、間違いなく最も重要な方法です。
  Fabricを使い方と、どのように使いたいかそ知りましょう。(最初に `ticket tracker <http://code.fabfile.org>`_ 
  を検索してみて見つからなかったらアイディアを送ってください。


* **バグの報告** 前項のかなり特殊なケース：もしFabricにバグを見つけたら　`Redmine ticket tracker
  <http://code.fabfile.org>`_ を見て、他の誰かが報告してないか調べてください。
  そして無ければ、バグを提出してください！できれば何度も再現できるか確かめて、その時の環境(使ったFabricのバージョン、プラットフォーム、
  バグが発生したときに何をしていたか)を知らせてください。

* **パッチや新機能を投稿する** こちらのドキュメント :ref:`source-code-checkouts` をみて、ソースをGitから
  クローンしてメーリングリストにパッチを送るか、GitHubのfork(もしくはそのforkの特定のコミット)のリンクをRedmineのチケットで
  投稿してください。
  すぐに返事を出せないかもしれませんが、最終的にはすべてに目を通します。そして組み込むか、なぜその変更がふさわしくないか説明します。

コミュニケーション
------------

ある問題に関するチケットトラッカーのチケットがあるなら、 **お願いですから** 、そのチケットのコメントとコミュニケーションし続けてください。
例えばGithubを通してパッチを提出するときは、 **プルリクエストを送る代わりに** 、チケットにノートを残してくれたほうが助かります。

コア開発者はチケットトラッカーのアクティビティを知るためにEメールを使っています。なので、Githubやその他から連絡されても開発が遅くなるだけです。

スタイル
------

Fabricは `PEP-8`_ に敬意を評し、特に以下の点に従います。

* すべての行の最大長は79文字とします。ReSTドキュメントも同様に。

  *  例外は、長い文字列がブレーク(例えば文字列が ``print``-ed で始まるソースコードや長いリンクが貼られたドキュメント)
     されたときに発生し、痛手を負うことになります。

* インデントは4スペース(ソフトタブ)を使いましょう。No タブ！No 8スペース！(2，3スペースとかその他もダメ！)

* クラスの名前には ``CamelCase`` 、その他すべては ``lowercase_underscore_separated`` を使いましょう。

.. _PEP-8: http://www.python.org/dev/peps/pep-0008/

ブランチ/リポジトリのレイアウト
=====================

Fabricの開発手法が決定されていない間、Gitリポジトリの整理や、マージのなどを以下の項目で詳細に記します。 
これはリリースバージョン以外のGitブランチを相手にしてる人だけでなく、どんな貢献者にも興味深いものでしょう。


* 私たちは 'リリースブランチとフィーチャーブランチ' の2つで開発をすすめています。小さいリリースはバグフィックスを目的としたリリースブランチで行われます(例えば、0.9、1.0、1.1、1.1など。バージョンの詳細は以下の :ref:`releases` を参照してください)。機能開発はマスターブランチか専用のブランチ、もしくは両方で行います。(スレッドセーフにするためや、タスクの依存を修正するためなど)

* 各リリースは ``0.9``, ``1.0``, ``1.1`` などのブランチがあり、 ``0.9.3`` や ``1.0.0`` のようにタグ付されています。

フィーチャーブランチの名前は ``<ticket number>-<short-description>`` の規則によってつけられます。例えばチケット#61で ``get`` と ``put`` に ``cd`` がサポートされるとすると、ブランチの名前は ``61-add-cd-to-get-put`` となります。

  * これらのブランチは実用を意図していませんのでリポジトリから定期的に消されることがあります。理想的には、実用された時点で消されるべきです！

* 新機能がマスターブランチにマージされた時点で、新しいリリースブランチがテスト用にリリースブランチとして作られることがあります。単に、そのままリリースされることもあります。

* バグのあるコードをコミットしたり、いきなりAPIを変えたりしないようベストを尽くしています。しかし、他の多くのオープンソース・プロジェクトと同じく、リリースブランチの安定性しか保証できません。多少痛手を負っても構わないなら、 ``master`` (それともフィーチャーブランチ!)を使ってください。

* リリースブランチは比較的安定させています。手動でバージョンアップするより、リリースブランチをチェックアウトすることをオススメします。バグフィックスやバックポートを簡単に手にいれ、能力と安定性のイイトコ取りができます。

* コア開発者は公式リポジトリでのマージ/ブランチを慎重に行います。GitがGitである限り、コントリビュータは自身のクローン/フォークで何でもできます。

* バグフィックスはリリースブランチで実行されてから ``master`` にマージされるので、 ``master`` はいつも最新です。(すべてのバグフィックスの後にマージするは義務ではありません。しかし毎日そうするのはいいアイディアです)。

* フィーチャーブランチを ``master`` にマージするときに苦労しないためにも、変更点は定期的にマージすべきです。

.. _releases:

リリース
======

Fabrciのリリースのタグ付けはオープンソースの規格と慣例にしたがっています。例えば2.0、1.2.5や1.2b1などの標準的なバージョン番号を含みます。それぞれのリリースはGitリポジトリーのタグを付けられ、以下の通りに分けられます:

メジャー
------

先頭の番号が更新されることをメジャーリリースといいます(例えば0.9が1.0になること)。これはソフトウェアが大きい節目に達したことを示しています。

例えば1.0リリースでは、長期的に使われるAPIと、(0.9シリーズと互換性のない)重要な機能がコミットされました。 バージョン2.0では、新しいネットワーク技術が使われるようになるか、よりオブジェクト指向になるでしょう。

メジャーリリースに後方互換性が無いのはよくあることです。必要条件ではなくとも当然の理です。
大抵、メジャーバージョンを変えるとfabfilesへの変更も必要になります。

マイナー
------

マイナーリリースは2番目の数字が変更されます(例えば1.0から1.1)。通常は新機能の追加を意味します。バグフィックスや機能修正が多くあると変更されることもあります。(両方同時に行われることもあります)

すべてのマイナーリリースは同じメジャーバージョン上で後方互換性があます。1.0で動作するfabfileは全く同じように1.1や1.9でも動作します。

バグフィックス
----------

バージョン番号の3番目はバグフィックスがあると変更されます(例えば1.0.3の'3')、小さな機能変更があったときも変更されるかもしれません(めったに無いでしょう)。

メジャー、マイナーリリースの最初のバージョン番号ではこの3番目の数字が省略されます(例えば、1.2や2.0)。この場合暗黙のゼロがあります(例えば、2.0.0)。

.. note::

    0.9シリーズではバージョン番号の3番目の変更に、今よりも重要な機能実装を含んでいました。1.0からは上記の通り、一般的なアプローチを使っています。

旧リリースのサポート
==============

メジャー、マイナーリリースがあったからといって、それ以前の開発が終わるわけではありません。

* 最新とその1つ前のマイナーリリースブランチが重要なバグフィックスを受け取り続けるでしょう。例えば、1.1が最新のマイナーリリースであれば、それと1.0がバグフィックスを受けとります(0.9より前は無関係です)。1.2が出ると、それと1.1が対象になります。

* 発見されたバグの修正が困難な場合は、より古いリリースがバグフィックスの対象になることもあります。そのリリースの保証が一切無くなります。1.1で見つかったバグの原因が0.9だとすると、すぐに修正されるべきならバージョン0.9.xが *ほぼ間違いなく* リリースされるでしょう。

* 将来的にこのポリシーは変更されるかもしれません。開発スピードが上がると、より多くのブランチに対応する必要がでてくるからです。

私たちは、このポリシーによって高速なマイナーリリースサイクルを実現し、新機能を頻繁に実装したいと思っています(ユーザがアップデートにプレッシャーを感じすぎない程度に)。同時に、後方互換性によってマイナーアップグレードが簡単に行えるべきです(ユーザがこのサポートページに留まり続けるためにも)。
